<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>DeepSeek Chat by 风扇</title>

<!-- highlight.js for client-side syntax highlighting -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

<style>
  :root{
    --bg:#0F1113;
    --panel:#191B1E;
    --muted:#8b949e;
    --bubble:#242628;
    --accent:#0066CC;
    --radius:14px;
    --safe-bottom: env(safe-area-inset-bottom, 12px);
    --bottom-height: 76px; /* 基础底部空间, 会在 runtime 动态调整 */
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family: Inter, "Helvetica Neue", Arial, sans-serif;-webkit-font-smoothing:antialiased}
  .app{display:flex;flex-direction:column;min-height:100vh;gap:0}
  header{padding:14px 12px;background:var(--panel);border-bottom:1px solid rgba(255,255,255,0.05);display:flex;justify-content:space-between;align-items:center}
  .ai-box{display:flex;flex-direction:column}
  .ai-title{
    font-weight:600;font-size:16px;letter-spacing:0.2px;display:flex;align-items:center;
  }
  .signature{font-size:12px;color:var(--muted);margin-top:4px}
  main{flex:1;overflow:auto;padding:16px;padding-bottom:calc(var(--bottom-height) + var(--safe-bottom));display:flex;flex-direction:column;gap:12px}
  .messages{display:flex;flex-direction:column;gap:12px;align-items:stretch}
  .msg{max-width:78%;padding:10px 12px;border-radius:12px;font-size:15px;line-height:1.45;word-break:break-word;white-space:pre-wrap;background:var(--bubble)}
  .msg.user{margin-left:auto;text-align:left}
  .msg.ai{margin-right:auto;text-align:left}
  .meta{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;flex-direction:column;align-items:flex-start;gap:4px}
  .nick{font-weight:700;color:#fff;display:flex;align-items:center}
  /* 打字动画小点点：放在昵称下面 */
  .typing-dots{display:inline-flex;gap:6px;margin-top:2px}
  .typing-dots span{width:6px;height:6px;background:var(--muted);border-radius:50%;display:inline-block;animation:blink 1.4s infinite}
  .typing-dots span:nth-child(2){animation-delay:0.2s}
  .typing-dots span:nth-child(3){animation-delay:0.4s}
  @keyframes blink{0%,80%,100%{opacity:.3}40%{opacity:1}}
  /* spacer：确保最后消息不会被固定底部覆盖 */
  .messages-spacer{height:var(--bottom-height);flex-shrink:0}
  /* 固定底部，动态调整 bottom 值由脚本控制以适配键盘 */
  .bottom{position:fixed;left:0;right:0;padding:12px 12px calc(12px + var(--safe-bottom));backdrop-filter: blur(6px);background:var(--panel);border-top:1px solid rgba(255,255,255,0.05);z-index:8;transition:bottom 160ms ease}
  .composer{display:flex;gap:8px;align-items:center}
  textarea#input{flex:1;min-height:44px;max-height:240px;border-radius:12px;border:1px solid rgba(255,255,255,0.08);background:#1a1c1e;padding:12px 14px;color:#e6eef6;resize:none;font-size:15px;overflow-y:auto;line-height:1.4;transition:width 160ms ease,height 160ms ease,padding 160ms ease}
  .send-btn{background:var(--accent);color:white;padding:10px 12px;border-radius:12px;border:none;font-weight:600;cursor:pointer}
  .settings-btn,.clear-btn{background:none;border:none;color:var(--muted);cursor:pointer;font-size:18px;margin-left:8px}
  /* 弹窗 */
  .modal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:none;justify-content:center;align-items:center;z-index:10}
  .modal-content{background:var(--panel);padding:18px;border-radius:var(--radius);width:92%;max-width:520px;box-shadow:0 0 10px rgba(0,0,0,0.4);display:flex;flex-direction:column;gap:6px}
  .modal-content h2{margin:0 0 8px 0;font-size:18px}
  /* label + input 对齐，所有输入均占满宽度 */
  .modal-row{display:flex;flex-direction:column;gap:6px;}
  .modal-content label{color:var(--muted);font-size:13px}
  .modal-content input[type="text"], .modal-content input[type="search"], .modal-content input[type="password"]{
    width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:#0F1113;color:#e6eef6;outline:none;box-sizing:border-box;
  }
  /* 自定义提示词改为 textarea，用于大段文字，但保持与其它输入对齐 */
  .modal-content textarea{width:100%;min-height:120px;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:#0F1113;color:#e6eef6;outline:none;box-sizing:border-box;resize:vertical}
  .modal-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:8px}
  .btn{padding:8px 12px;border:none;border-radius:8px;cursor:pointer;font-weight:600}
  .btn.save{Background:var(--accent);color:#fff}
  .btn.close{background:#333;color:#ccc}
  /* 微调消息容器滚动平滑 */
  main, .messages {scroll-behavior: smooth;}

  /* ======= Markdown & code block styles (调整为更紧凑) ======= */
  .msg pre {
    background: #0b0c0d;
    border-radius:8px;
    padding:12px;
    margin:6px 0;
    overflow:auto;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
    font-size:13px;
    line-height:1.45;
    border:1px solid rgba(255,255,255,0.04);
    white-space:pre; /* code 高亮更准确 */
    word-break:normal;
    position:relative; /* 为右上角按钮定位 */
  }
  .msg code.inline {
    background: rgba(255,255,255,0.03);
    padding:2px 6px;
    border-radius:6px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace;
    font-size:13px;
  }

  /* small adjustments for headings / paragraphs to reduce large gaps */
  .msg h1, .msg h2, .msg h3, .msg h4 {
    margin:8px 0 6px;
    color:#fff;
  }
  .msg p{margin:6px 0}
  .msg ul{margin:6px 0 8px 18px;padding:0}
  .msg ol{margin:6px 0 8px 18px;padding:0}
  .msg li{margin:6px 0}
  .msg blockquote{
    margin:6px 0;padding:8px 12px;border-left:3px solid rgba(255,255,255,0.06);
    color:var(--muted);background:rgba(255,255,255,0.02);border-radius:8px;
  }
  .msg a{color:var(--accent);text-decoration:none}
  .msg a:hover{text-decoration:underline}

  /* copy button (半透明圆角灰色) */
  .code-controls {
    position:absolute;
    top:8px;
    right:8px;
    display:flex;
    gap:6px;
    align-items:center;
    z-index:5;
  }
  .copy-btn {
    background: rgba(255,255,255,0.06);
    color: #e6eef6;
    border: none;
    padding:6px 8px;
    border-radius:8px;
    font-size:12px;
    cursor:pointer;
    backdrop-filter: blur(4px);
  }
  .copy-btn:active { transform: translateY(1px); }
  .lang-badge {
    background: rgba(255,255,255,0.03);
    color: var(--muted);
    padding:4px 6px;
    border-radius:8px;
    font-size:11px;
  }

  @media (max-height:600px){
    .modal-content{max-height:80vh;overflow:auto}
  }

  /* ====== 思维链 (reasoning) 样式 ====== */
  .reasoning-box {
    margin-top:8px;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.03);
    padding:10px;
    border-radius:10px;
    color:var(--muted);
    font-size:13px;
    line-height:1.45;
    /* 确保展开时没有阴影 */
    box-shadow: none;
  }
  .reasoning-toggle {
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    margin-top:8px;
  }
  .reasoning-toggle button {
    background: transparent;
    color: var(--muted);
    border:1px solid rgba(255,255,255,0.04);
    padding:6px 8px;
    border-radius:8px;
    cursor:pointer;
    font-size:12px;
  }
  .reason-label { font-size:12px;color:var(--muted); }
  /* 折叠状态：完全隐藏（不显示预览、不加渐变） */
  .reasoning-collapsed {
    display: none;
  }

  /* 输入框 collapsed 状态（未聚焦） */
  textarea.collapsed {
    width: 160px; /* 收起时较窄，和发送按钮在一行对齐，视觉更简洁 */
    padding-top:8px;
    padding-bottom:8px;
    height:44px;
  }
  /* 聚焦时恢复 flex:1 */
  textarea.expanded {
    width: auto;
    flex:1;
  }
  /* small device tweak: 收起宽度不要太窄 */
  @media (max-width:420px){
    textarea.collapsed { width: 120px; }
  }

  /* Toggle 行内样式（用类代替内联样式，保证与上一个选项的垂直间距由 .modal-row 控制） */
  .toggle-row{display:flex;align-items:center;gap:10px;}
  .toggle-desc{color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="ai-box">
      <div class="ai-title" id="headerTitle">
        <div id="aiTitleText">和deepseek聊天！</div>
      </div>
      <div class="signature" id="signature"></div>
    </div>
    <div>
      <button class="clear-btn" id="clearHistory" title="清除历史">🗑️</button>
      <button class="settings-btn" id="openSettings" title="设置">⚙️</button>
    </div>
  </header>
  <main>
    <div class="messages" id="messages"></div>
  </main>
  <div class="bottom" id="bottom">
    <div class="composer">
      <textarea id="input" placeholder="Enter your text." rows="1" aria-label="消息输入"></textarea>
      <button id="send" class="send-btn">发送</button>
    </div>
  </div>
</div>

    <!-- 设置弹窗（保留 AI 昵称、个性签名与自定义提示词，并新增 API Key 与思考开关） -->
<div class="modal" id="settingsModal">
  <div class="modal-content">
    <h2>设置</h2>
    <div class="modal-row">
      <label for="aiNick">昵称 Name</label>
      <input id="aiNick" type="text" value="小风" />
    </div>

    <div class="modal-row">
      <label for="signatureInput">个签 Introduction</label>
      <input id="signatureInput" type="text" placeholder="例如：Fly to the sky" />
    </div>

    <div class="modal-row">
      <label for="userPrompt">性格 Character</label>
      <textarea id="userPrompt" placeholder="定义AI的性格、说话方式（在这里重复AI的名字"></textarea>
    </div>

    <div class="modal-row">
      <label for="apiKeyInput">API Key（本地保存）</label>
      <input id="apiKeyInput" type="password" placeholder="sk-xxxxxxxxx" />
    </div>

    <div class="modal-row">
      <label for="reasoningToggle">深度思考</label>
      <div class="toggle-row">
        <input id="reasoningToggle" type="checkbox" />
        <div class="toggle-desc">开启后将深度思考</div>
      </div>
    </div>

    <!-- 新增项：默认折叠思维链 -->
    <div class="modal-row">
      <div class="toggle-row">
        <input id="defaultReasonCollapsedToggle" type="checkbox" />
        <div class="toggle-desc">开启后将默认不展示思维链</div>
      </div>
    </div>

    <div class="modal-actions">
      <button class="btn close" id="closeSettings">取消</button>
      <button class="btn save" id="saveSettings">保存</button>
    </div>
  </div>
</div>

<script>

const API_BASE = "https://api.deepseek.com";
const MODEL_CHAT = "deepseek-chat";
const MODEL_REASONER = "deepseek-reasoner";
const STORAGE_KEY = "deepseek_chat_autosave";
const SETTINGS_KEY = "deepseek_chat_settings";

const msgsEl = document.getElementById("messages");
const inputEl = document.getElementById("input");
const sendBtn = document.getElementById("send");
const aiNickEl = document.getElementById("aiNick");
const aiTitleTextEl = document.getElementById("aiTitleText");
const signatureEl = document.getElementById("signature");
const signatureInputEl = document.getElementById("signatureInput");
const userPromptEl = document.getElementById("userPrompt");
const apiKeyEl = document.getElementById("apiKeyInput");
const reasoningToggleEl = document.getElementById("reasoningToggle");
// 新增的默认折叠开关元素
const defaultReasonCollapsedToggleEl = document.getElementById("defaultReasonCollapsedToggle");

const settingsModal = document.getElementById("settingsModal");
const openSettingsBtn = document.getElementById("openSettings");
const closeSettingsBtn = document.getElementById("closeSettings");
const saveSettingsBtn = document.getElementById("saveSettings");
const clearHistoryBtn = document.getElementById("clearHistory");
const bottomEl = document.getElementById("bottom");
const headerTitle = document.getElementById("headerTitle");

let messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");

/* ------------------ Markdown helpers (安全、轻量、改进) ------------------ */
function escapeHtml(str){
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

/**
 * 提取代码块（支持未闭合的起始 ```：把剩余当 code 内容）
 * 返回 {text: replacedText, codeBlocks: [...]}
 */
function extractCodeBlocksRaw(text){
  const codeBlocks = [];
  let out = "";
  let pos = 0;
  while(true){
    const start = text.indexOf("```", pos);
    if(start === -1){
      out += text.slice(pos);
      break;
    }
    // append before fence
    out += text.slice(pos, start);
    // find matching end
    const end = text.indexOf("```", start + 3);
    const between = (end === -1) ? text.slice(start + 3) : text.slice(start + 3, end);
    // detect optional language on first line
    const m = between.match(/^([^\n]*)\n([\s\S]*)$/);
    let lang = "", code = "";
    if(m){
      lang = m[1].trim();
      code = m[2];
    } else {
      // 没有明确的语言行，把整个 between 视为 code 内容（可能包括 single-line code）
      lang = "";
      code = between;
    }
    const idx = codeBlocks.length;
    codeBlocks.push({lang, code});
    out += `@@CODEBLOCK_${idx}@@`;
    if(end === -1){
      // 未闭合，已经消费到文本末尾，退出
      pos = text.length;
      break;
    } else {
      pos = end + 3;
      continue;
    }
  }
  return {text: out, codeBlocks};
}

/**
 * 将简易 Markdown 转为安全的 HTML（支持代码块、行内代码、粗体、斜体、标题、列表、链接、引用）
 * - 先抽取代码块占位，防止被转义或误解析
 * - 将连续的普通文本合并为段落（更紧凑）
 */
function markdownToHtml(input){
  if(input === null || input === undefined) return "";

  // 标准化换行
  let text = String(input).replace(/\r\n/g, "\n");

  // 抽取代码块（支持未闭合）
  const extracted = extractCodeBlocksRaw(text);
  text = extracted.text;
  const codeBlocks = extracted.codeBlocks;

  // 分行处理（合并连续行到一个 <p>）
  const lines = text.split("\n");
  const outParts = [];
  let paragraph = null;
  let inUl = false, inOl = false;

  function flushParagraph(){
    if(paragraph !== null){
      outParts.push(`<p>${paragraph}</p>`);
      paragraph = null;
    }
  }

  for(let i = 0; i < lines.length; i++){
    let line = lines[i];

    // heading
    const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
    if(headingMatch){
      flushParagraph();
      if(inUl){ outParts.push("</ul>"); inUl = false; }
      if(inOl){ outParts.push("</ol>"); inOl = false; }
      const level = headingMatch[1].length;
      outParts.push(`<h${level}>${inlineFormatting(escapeHtml(headingMatch[2]))}</h${level}>`);
      continue;
    }

    // blockquote
    if(line.trim().startsWith(">")){
      flushParagraph();
      if(inUl){ outParts.push("</ul>"); inUl = false; }
      if(inOl){ outParts.push("</ol>"); inOl = false; }
      const inner = line.replace(/^\s*>\s?/, "");
      outParts.push(`<blockquote>${inlineFormatting(escapeHtml(inner))}</blockquote>`);
      continue;
    }

    // unordered list
    const ulMatch = line.match(/^\s*[-*+]\s+(.*)$/);
    if(ulMatch){
      flushParagraph();
      if(inOl){ outParts.push("</ol>"); inOl = false; }
      if(!inUl){
        outParts.push("<ul>");
        inUl = true;
      }
      outParts.push(`<li>${inlineFormatting(escapeHtml(ulMatch[1]))}</li>`);
      continue;
    } else if(inUl && line.trim() === ""){
      outParts.push("</ul>");
      inUl = false;
      continue;
    }

    // ordered list
    const olMatch = line.match(/^\s*\d+\.\s+(.*)$/);
    if(olMatch){
      flushParagraph();
      if(inUl){ outParts.push("</ul>"); inUl = false; }
      if(!inOl){
        outParts.push("<ol>");
        inOl = true;
      }
      outParts.push(`<li>${inlineFormatting(escapeHtml(olMatch[1]))}</li>`);
      continue;
    } else if(inOl && line.trim() === ""){
      outParts.push("</ol>");
      inOl = false;
      continue;
    }

    // 空行 -> 段落分隔
    if(line.trim() === ""){
      flushParagraph();
      continue;
    }

    // 普通文本行：合并到当前 paragraph
    const formatted = inlineFormatting(escapeHtml(line.trim()));
    if(paragraph === null){
      paragraph = formatted;
    } else {
      // 使用空格分隔原始行，保留更紧凑的视觉效果
      paragraph += " " + formatted;
    }
  }

  flushParagraph();
  if(inUl) outParts.push("</ul>");
  if(inOl) outParts.push("</ol>");

  let html = outParts.join("\n");

  // 恢复代码块占位（并对代码内容做 escapeHtml）
  html = html.replace(/@@CODEBLOCK_(\d+)@@/g, (m, idx) => {
    const cb = codeBlocks[Number(idx)];
    if(!cb) return "";
    const escapedCode = escapeHtml(cb.code);
    const langClass = cb.lang ? ` class="language-${escapeHtml(cb.lang)}"` : "";
    // 给 code 元素加上 inline class 名称（highlight.js 可自动检测），并保留 language- 前缀给角标使用
    return `<pre><code${langClass}>${escapedCode}</code></pre>`;
  });

  return html;
}

/**
 * 行内格式（作用在已 escape 的文本）
 * 支持：
 *  - 行内代码 `code`
 *  - 粗体 **text**
 *  - 斜体 *text*
 *  - 链接 [text](url)
 *
 * 注意：假定输入已 escapeHtml 过
 */
function inlineFormatting(escapedText){
  if(!escapedText) return "";

  // 行内代码先占位
  const codePlaceholders = [];
  escapedText = escapedText.replace(/`([^`]+)`/g, (m, code) => {
    const idx = codePlaceholders.length;
    codePlaceholders.push(code);
    return `@@INLINECODE_${idx}@@`;
  });

  // 链接 [text](url)
  escapedText = escapedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, url) => {
    const safeText = text; // 已 escapeHtml
    const safeUrl = (/^(https?:\/\/|mailto:)/i.test(url) ? escapeHtml(url) : "#");
    return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeText}</a>`;
  });

  // 粗体 **text**
  escapedText = escapedText.replace(/\*\*(.+?)\*\*/g, (m, t) => `<strong>${t}</strong>`);

  // 斜体 *text* （避免与 ** 冲突）
  escapedText = escapedText.replace(/(^|[^*])\*([^*]+)\*([^*]|$)/g, (m, a, t, b) => {
    const left = a;
    const right = b;
    return `${left}<em>${t}</em>${right}`;
  });

  // 恢复行内代码
  escapedText = escapedText.replace(/@@INLINECODE_(\d+)@@/g, (m, idx) => {
    const code = codePlaceholders[Number(idx)];
    return `<code class="inline">${code}</code>`;
  });

  return escapedText;
}

/* ------------------ 渲染消息（使用 Markdown 渲染） ------------------ */
function renderMessages() {
  msgsEl.innerHTML = "";
  for (const m of messages) {
    if(m.role==="system") continue;
    const el = document.createElement("div");
    el.className = "msg " + (m.role === "user" ? "user" : "ai");

    // 为 AI 消息显示 meta（昵称 + 打字点）
    if(m.role === "assistant") {
      const meta = document.createElement("div");
      meta.className = "meta";
      const nickWrap = document.createElement("div");
      nickWrap.className = "nick";

      // 文本昵称
      const nick = document.createElement("span");
      nick.textContent = aiNickEl.value || "AI";

      nickWrap.appendChild(nick);
      meta.appendChild(nickWrap);

      // AI 正在打字的状态
      if(m.content==="_typing"){
        const dots = document.createElement("div");
        dots.className = "typing-dots";
        dots.innerHTML = "<span></span><span></span><span></span>";
        meta.appendChild(dots);
        el.appendChild(meta);
        msgsEl.appendChild(el);
        continue;
      }
      el.appendChild(meta);
    }

    const content = document.createElement("div");

    // === 修改点：如果是用户（user）的消息，作为纯文本渲染（textContent）
    if (m.role === "user") {
      content.textContent = m.content;
      el.appendChild(content);
    } else {
      // AI 消息仍然支持 markdown -> HTML（包含 code block）
      // 但我们需要把 reasoning（思维链）单独作为折叠面板渲染
      content.innerHTML = markdownToHtml(m.content || "");
      el.appendChild(content);

      // 如果有 reasoning 字段，则渲染折叠区域
      if(m.reasoning){
        // container for toggle + collapsed reasoning
        const toggleWrap = document.createElement("div");
        toggleWrap.className = "reasoning-toggle";

        const label = document.createElement("div");
        label.className = "reason-label";
        label.textContent = "深度思考 Reasoning";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = m.reasonCollapsed ? "展开思维链" : "收起思考链";
        btn.addEventListener("click", ()=>{
          m.reasonCollapsed = !m.reasonCollapsed;
          // 保存到 storage
          localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
          renderMessages();
        });

        toggleWrap.appendChild(label);
        toggleWrap.appendChild(btn);
        el.appendChild(toggleWrap);

        // reasoning content box
        const rbox = document.createElement("div");
        rbox.className = "reasoning-box";

        if(m.reasonCollapsed){
          // 折叠后：完全隐藏（不渲染预览、不显示渐变）
          rbox.style.display = "none";
        } else {
          // fully expanded: render reasoning content (确保没有阴影)
          rbox.style.display = "";
          rbox.style.boxShadow = "none";
          rbox.innerHTML = markdownToHtml(m.reasoning || "");
        }
        el.appendChild(rbox);
      }
    }

    msgsEl.appendChild(el);
  }

  // 在消息列表末尾添加 spacer，避免固定底部遮挡最后一条消息
  const spacer = document.createElement("div");
  spacer.className = "messages-spacer";
  msgsEl.appendChild(spacer);

  // 滚动到底部
  const container = msgsEl.parentElement;
  container.scrollTop = container.scrollHeight;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));

  // 增强：对所有 code block 注入复制按钮并执行高亮
  enhanceCodeBlocks();
}

/* ---------- 为 code blocks 注入复制按钮与语言角标，并执行 highlight ---------- */
function enhanceCodeBlocks(){
  // highlight.js 全局函数 hljs 可用（通过 CDN 引入）
  // 1. 找到所有 <pre><code>
  const pres = msgsEl.querySelectorAll("pre");
  pres.forEach(pre => {
    // 防止重复注入
    if(pre.dataset.enhanced === "1") return;
    pre.dataset.enhanced = "1";

    const codeEl = pre.querySelector("code");
    if(!codeEl) return;

    // 语言角标：从 class name 提取 language-xxx 或者尝试 hljs 自动检测
    let langLabel = "";
    const classList = Array.from(codeEl.classList || []);
    const langCls = classList.find(c => /^language-/.test(c) || /^hljs-/.test(c));
    if(langCls){
      langLabel = langCls.replace(/^language-/, "").replace(/^hljs-/, "");
    } else {
      // 尝试自动检测（hljs.getLanguage）
      try {
        const detected = hljs.highlightAuto(codeEl.textContent || "");
        if(detected && detected.language) langLabel = detected.language;
      } catch(e){}
    }

    // 创建右上角容器（语言角标 + 复制按钮）
    const controls = document.createElement("div");
    controls.className = "code-controls";

    // language badge
    if(langLabel){
      const lb = document.createElement("div");
      lb.className = "lang-badge";
      lb.textContent = langLabel;
      controls.appendChild(lb);
    }

    // copy button
    const copyBtn = document.createElement("button");
    copyBtn.className = "copy-btn";
    copyBtn.type = "button";
    copyBtn.title = "复制代码";
    copyBtn.textContent = "Copy";
    controls.appendChild(copyBtn);

    pre.appendChild(controls);

    // copy action
    copyBtn.addEventListener("click", async () => {
      const codeText = codeEl.textContent || "";
      try{
        await navigator.clipboard.writeText(codeText);
        const original = copyBtn.textContent;
        copyBtn.textContent = "已复制";
        setTimeout(()=> copyBtn.textContent = original, 1200);
      }catch(e){
        // fallback
        const ta = document.createElement("textarea");
        ta.value = codeText;
        document.body.appendChild(ta);
        ta.select();
        try{
          document.execCommand('copy');
          const original = copyBtn.textContent;
          copyBtn.textContent = "已复制";
          setTimeout(()=> copyBtn.textContent = original, 1200);
        }catch(err){
          alert("复制失败，请手动复制代码");
        } finally {
          document.body.removeChild(ta);
        }
      }
    });

    // 让 highlight.js 高亮（如果 library 加载完会工作）
    try{
      hljs.highlightElement(codeEl);
    }catch(e){}
  });
}

/* ---------- 消息管理 ---------- */
function addMessage(role, content, extra = {}) {
  // extra 可以包含 reasoning, reasonCollapsed, id
  const msg = Object.assign({role, content}, extra);
  // ensure id
  if(!msg.id) msg.id = `m_${Date.now()}_${Math.floor(Math.random()*1000)}`;

  // **关键改动**：如果是 assistant 且未显式设置 reasonCollapsed，默认使用设置（仅当“深度思考”模式被启用时才应用该默认折叠设定）
  if(msg.role === "assistant" && typeof msg.reasonCollapsed === "undefined"){
    // 只有在 reasoner 模式开启时，才把默认折叠设置应用于 assistant 消息（避免影响普通聊天模型）
    msg.reasonCollapsed = (isReasoningEnabled() && isDefaultReasonCollapsed()) ? true : false;
  }

  messages.push(msg);
  renderMessages();
}

function getBeijingTime(){
  const now = new Date();
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  const bj = new Date(utc + 8*3600*1000);
  return bj.toLocaleString("zh-CN", {hour12:false});
}

/* ---------- 获取/存储 设置（包含 API Key & reasoning 开关） ---------- */
function loadSettings(){
  const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}");
  if(s.aiNick) aiNickEl.value = s.aiNick;
  if(s.signature) signatureInputEl.value = s.signature;
  if(s.userPrompt) userPromptEl.value = s.userPrompt;
  if(s.apiKey) apiKeyEl.value = s.apiKey;
  if(typeof s.reasoningEnabled !== "undefined") reasoningToggleEl.checked = !!s.reasoningEnabled;
  // 新增：读取默认折叠思维链开关
  if(typeof s.defaultReasonCollapsed !== "undefined") defaultReasonCollapsedToggleEl.checked = !!s.defaultReasonCollapsed;
  aiTitleTextEl.textContent = aiNickEl.value || "AI 聊天";
  signatureEl.textContent = signatureInputEl.value || "";
}

function saveSettings(){
  const settings = {
    aiNick: aiNickEl.value,
    signature: signatureInputEl.value,
    userPrompt: userPromptEl.value,
    apiKey: apiKeyEl.value,
    reasoningEnabled: reasoningToggleEl.checked,
    // 新增：保存默认折叠思维链开关
    defaultReasonCollapsed: defaultReasonCollapsedToggleEl.checked
  };
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  headerTitleUpdate();
}

/* 读取当前保存的 API Key（不打印、不泄露） */
function getApiKey(){
  const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}");
  return s.apiKey || "";
}
function isReasoningEnabled(){
  const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}");
  return !!s.reasoningEnabled;
}
// 新增：判断“默认折叠思维链”是否开启
function isDefaultReasonCollapsed(){
  const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}");
  return !!s.defaultReasonCollapsed;
}

function headerTitleUpdate(){
  aiTitleTextEl.textContent = aiNickEl.value || "AI 聊天";
  signatureEl.textContent = signatureInputEl.value || "";
}

/* ---------- 发送并流式接收（保持原逻辑，但使用本地存储的 API Key，并支持 reasoning） ---------- */
async function sendMessage(){
  const text = inputEl.value.trim();
  if(!text) return;
  inputEl.value = "";
  inputEl.style.height = "44px"; // 重置高度
  // add user message
  addMessage("user", text);

  const sysPrompt = `现在是 ${getBeijingTime()}（北京时间）你正在通过网页和用户聊天\n用户提示：${userPromptEl.value||""}`;
  // build messages for API: include system + conversation (only role/content)
  const apiMessages = [{role:"system", content: sysPrompt}];
  for(const m of messages){
    // filter out assistant typing placeholder
    if(m.role==="assistant" && m.content==="_typing") continue;
    if(m.role === "assistant" || m.role === "user"){
      apiMessages.push({role:m.role, content:m.content});
    }
  }

  // 添加 AI 正在打字的占位气泡（包含 id）
  const placeholderId = `m_${Date.now()}_${Math.floor(Math.random()*1000)}`;
  // **关键改动**：占位符的 reasonCollapsed 应依据设置（仅在 deep-reasoner 模式启用时应用默认折叠）
  const placeholderReasonCollapsed = (isReasoningEnabled() && isDefaultReasonCollapsed()) ? true : false;
  addMessage("assistant","_typing",{id:placeholderId, reasoning: null, reasonCollapsed: placeholderReasonCollapsed});
  let replyMessageIndex = messages.findIndex(mm => mm.id === placeholderId);
  if(replyMessageIndex === -1) replyMessageIndex = messages.length - 1;

  try {
    const apiKey = getApiKey();
    if(!apiKey){
      // 如果没有配置 Key，提示用户并把占位替换为错误内容
      const reply = {role:"assistant", content: "\n[错误] 请在设置中填写 API Key 后重试。", reasoning:null, reasonCollapsed:false, id:placeholderId};
      messages[replyMessageIndex] = reply;
      renderMessages();
      return;
    }

    // 根据设置选择模型
    const modelToUse = isReasoningEnabled() ? MODEL_REASONER : MODEL_CHAT;
    const url = API_BASE + "/chat/completions"; // note: example shows /chat/completions; original used /v1/chat/completions — both might be valid; keep as /chat/completions per provided example
    // Use stream: true to keep previous behavior (but gracefully handle non-stream)
    const useStream = true;
    const bodyObj = {model: modelToUse, messages: apiMessages, stream: useStream};
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type":"application/json",
        "Authorization":"Bearer "+apiKey
      },
      body: JSON.stringify(bodyObj)
    });

    if(!res.ok){
      // Try to parse error body for details
      let errText = `API 错误 ${res.status}`;
      try{ const errJson = await res.json(); if(errJson.error && errJson.error.message) errText += ": "+errJson.error.message;}catch(e){}
      throw new Error(errText);
    }

    if(useStream && res.body){
      // 流式处理（保留原来的流式合并逻辑），并尝试捕获 reasoning_content 字段
      const reader = res.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      // ensure the placeholder is an object we can update
      if(messages[replyMessageIndex].content==="_typing"){
        messages[replyMessageIndex] = {role:"assistant", content:"", reasoning:null, reasonCollapsed: placeholderReasonCollapsed, id:placeholderId};
      }
      let reply = messages[replyMessageIndex];
      while(true){
        const {done, value} = await reader.read();
        if(done) break;
        buffer += decoder.decode(value, {stream:true});
        const parts = buffer.split("\n\n");
        buffer = parts.pop();
        for(const part of parts){
          if(!part.startsWith("data:")) continue;
          const data = part.slice(5).trim();
          if(!data) continue;
          if(data==="[DONE]") continue;
          try{
            const obj = JSON.parse(data);
            // streaming delta may contain delta.content or delta.reasoning_content
            const delta = obj.choices?.[0]?.delta || {};
            if(delta.content){
              reply.content += delta.content;
              messages[replyMessageIndex] = reply;
              renderMessages();
            }
            if(delta.reasoning_content){
              // accumulate reasoning chunks in reply.reasoning
              reply.reasoning = (reply.reasoning || "") + delta.reasoning_content;
              messages[replyMessageIndex] = reply;
              renderMessages();
            }
            // Some servers stream top-level message pieces differently; if final chunk contains 'message' with both fields:
            const finishMessage = obj.choices?.[0]?.message;
            if(finishMessage){
              if(finishMessage.content) reply.content += finishMessage.content;
              if(finishMessage.reasoning_content) reply.reasoning = (reply.reasoning || "") + finishMessage.reasoning_content;
              messages[replyMessageIndex] = reply;
              renderMessages();
            }
          }catch(e){
            // ignore malformed chunk
          }
        }
      }
      // 流结束后确保把最终数据写回并保存
      messages[replyMessageIndex] = reply;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
      renderMessages();
    } else {
      // 非流式：直接 parse JSON
      const j = await res.json();
      // try to extract assistant message
      const choice = j.choices && j.choices[0];
      let assistantText = "";
      let reasoningText = null;
      if(choice){
        // some APIs use choice.message.content
        if(choice.message && typeof choice.message.content === "string"){
          assistantText = choice.message.content;
        } else if(choice.text){ // fallback
          assistantText = choice.text;
        }
        // reasoning content may be in message.reasoning_content or in other fields
        if(choice.message && typeof choice.message.reasoning_content === "string"){
          reasoningText = choice.message.reasoning_content;
        } else if(choice.reasoning_content){
          reasoningText = choice.reasoning_content;
        }
      }
      // Replace placeholder with final reply
      // **关键改动**：如果存在 reasoningText，则根据“默认折叠思维链”设置决定 reasonCollapsed
      const reply = {role:"assistant", content: assistantText || "[空回复]", reasoning: reasoningText, reasonCollapsed: (reasoningText ? isDefaultReasonCollapsed() : false), id:placeholderId};
      messages[replyMessageIndex] = reply;
      renderMessages();
    }
  }catch(e){
    // error handling: replace typing placeholder with error message
    const errMsg = {role:"assistant", content: "\n[错误] " + e.message, reasoning:null, reasonCollapsed:false, id:placeholderId};
    messages[replyMessageIndex] = errMsg;
    renderMessages();
  }
}

/* ---------- 弹窗逻辑 ---------- */
openSettingsBtn.addEventListener("click", ()=>{
  loadSettings();
  settingsModal.style.display="flex";
});
closeSettingsBtn.addEventListener("click", ()=>{settingsModal.style.display="none";});
saveSettingsBtn.addEventListener("click", ()=>{
  saveSettings();
  settingsModal.style.display="none";
  renderMessages();
});

/* ---------- 清空历史 ---------- */
clearHistoryBtn.addEventListener("click", ()=>{
  if(confirm("确定要清空所有聊天记录吗？")){
    messages = [];
    localStorage.removeItem(STORAGE_KEY);
    renderMessages();
  }
});

/* ---------- 发送事件 & 输入高度 & collapsed 行为 ---------- */
sendBtn.addEventListener("click", sendMessage);
inputEl.addEventListener("keydown", (e)=>{
  if((e.ctrlKey && e.key==="Enter") || (e.key==="Enter" && !e.shiftKey && !e.ctrlKey)){
    e.preventDefault();
    sendMessage();
    // keep expanded after sending
    setExpandedState(false);
  }
});
inputEl.addEventListener('input', ()=>{
  // if user types, ensure expanded
  setExpandedState(true);
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight,240)+"px";
});

/* ---------- 视觉视口（VisualViewport）用于处理键盘高度，避免间隙 ---------- */
const BASE_BOTTOM_HEIGHT = 76; // 与 css :root --bottom-height 基础保持一致
function updateForViewport(){
  const vv = window.visualViewport;
  let kb = 0;
  if(vv){
    // 计算键盘高度：窗口内高度（innerHeight）减去 visualViewport.height（受键盘影响）
    kb = Math.max(0, window.innerHeight - vv.height - (vv.offsetTop || 0));
  } else {
    // fallback: 使用 window.innerHeight 与 document.documentElement.clientHeight 之差（某些浏览器）
    kb = Math.max(0, window.innerHeight - document.documentElement.clientHeight);
  }
  // 设置 bottom 元素底部间距（固定定位），并更新 main 的 padding-bottom（通过 css 变量）
  bottomEl.style.bottom = (kb > 0 ? kb + 'px' : '0px');
  document.documentElement.style.setProperty('--bottom-height', `${BASE_BOTTOM_HEIGHT + kb}px`);
  // 当输入框获取焦点时确保滚动到底部（给移动端时间）
  setTimeout(()=>{ const container = msgsEl.parentElement; container.scrollTop = container.scrollHeight; }, 120);
}

/* 监听 visualViewport 变化（多数移动端浏览器支持），及 resize */
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', updateForViewport, {passive:true});
  window.visualViewport.addEventListener('scroll', updateForViewport, {passive:true});
}
window.addEventListener('resize', updateForViewport);
inputEl.addEventListener('focus', ()=>{
  // expand input on focus
  setExpandedState(true);
  setTimeout(()=>{ updateForViewport(); const container = msgsEl.parentElement; container.scrollTop = container.scrollHeight; }, 250);
});
inputEl.addEventListener('blur', ()=>{ 
  // if empty, collapse after small delay to allow click on send
  setTimeout(()=>{ if(!inputEl.value.trim()) setExpandedState(false); updateForViewport(); }, 160); 
});

/* ---------- 控制输入框 collapsed/expanded ---------- */
function setExpandedState(expand){
  if(expand){
    inputEl.classList.remove("collapsed");
    inputEl.classList.add("expanded");
    // let flex behavior take over
    inputEl.style.width = "";
  } else {
    // collapsed: only when no user content
    if(inputEl.value && inputEl.value.trim()) return;
    inputEl.classList.remove("expanded");
    inputEl.classList.add("collapsed");
    inputEl.style.height = "44px";
    inputEl.style.width = ""; // the .collapsed css sets width
  }
}

/* fallback 保证在 load 时正确设置 */
window.addEventListener("load", ()=>{
  loadSettings();
  headerTitleUpdate();
  // initialize collapsed state (start collapsed if input empty)
  if(!inputEl.value || !inputEl.value.trim()){
    inputEl.classList.add("collapsed");
  } else {
    inputEl.classList.add("expanded");
  }
  renderMessages();
  updateForViewport();
});

/* 兼容：在软键盘弹起后做一次最终滚动 */
window.addEventListener('orientationchange', ()=> setTimeout(updateForViewport, 300));
</script>
</body>
</html>